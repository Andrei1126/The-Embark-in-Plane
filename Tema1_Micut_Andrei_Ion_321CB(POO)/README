
/* Micut Andrei-Ion, Grupa 321CB */

											Imbarcarea pasagerilor in avion
												~Tema1~				

	Tema ce se refera la imbarcarea pasagerilor in avion am realizat-o prin intermediul a 9 clase: Pasager, Entitate, Familie, Grup, Singur, Heap, Imbarcare, MainReader, Main.

	Am debutat realizarea temei cu, clasa Pasager in care mi-am definit numarul de pasageri si caracteristicile despre fiecare pasager si bilet, asa cum s-a cerut in enuntul temei. Prima metoda creata a fost constructorul in care am initializat fiecare camp in parte, mai putin numarul de pasageri. Mi-am creat get-eri si set-eri pentru fiecare camp,just in case. Am continuat realizarea temei cu metoda sumPriority in care am calculat prioritatea fiecarui pasager in functie de cazurile prezentate in enunt.

	In clasa abstracta Entitate mi-am definit un pasager de tipul Pasager si o variabila de tipul integer, prioritate, prin care este transmisa prioritatea familiilor, grupurilor sau celor singuri. Mi-am creat get-er si set-er pentru prioritate si am suprascris metoda toString pentru a-mi returna id-ul pasagerului.

	Clasa Familie extinde clasa abstracta Entitate. Mi-am creat constructorul, iar in el am atribuit pentru priotatea familie, numarul de puncte necesare si am transmis ca parametru al metodei un pasager de tipul Pasager. Am realizat si metodele get si set pentru un pasager.

	Clasas Grup extinde clasa abstracta Entitate. Mi-am creat constructorul, iar in el am atribuit pentru priotatea familie, numarul de puncte necesare, am transmis ca parametru al metodei un pasager de tipul Pasager si am calculat prioritatea pentru un pasager. Am realizat si metodele get si set pentru un pasager.

	Clasa Singur extinde clasa abstracta Entitate si realizez metode si atribuiri ca in clasa Familie, iar, pe langa acestea, realizez si metoda de setare a prioritatii, setPrioritate, care imi seteaza prioritatea pentru pasagerul singur.

	In clasa Heap am definit un heap de tip Entitate, privat si o variabila de tip intreg, tot privata. In constructorul am initializat dimensiunea cu 0, iar heap-ul cu un vector de entitati de dimensiune 1. Metoda Este_Frunza ce are ca parametru al functiei pozitia, verifica daca pozitia transmisa este frunza. Daca dimensiunea heap-ului este 1, atunci voi atribui 1 variabilei mai sus declarata, altfel ii atribui jumatate din dimensiune. Verific daca pozitia data ca parametru este mai mare decat frunza si intorc true daca este asa sau false in caz contrar. Mi-am creat o metoda ce imi va intoarce parintele. Am continuat prin crearea metodei de inserare ce primeste ca parametru o entitate si prioritatea ei.Verific daca dimensiunea este 0, atunci avem o singura entitate, cresc dimensiunea si ies din functie. Imi voi declara o noua entitate, in interiorul functiei, pentru a-mi mari vectorul in care sunt retinute nodurile heap-ului si voi schimba referinta vechiului vector de heap. Cat timp prioritatea nodului curent este mai mare decat prioritatea parintelui, realizez interschimbarea, iar pozitia curenta va deveni nodul parinte. In cadrul metodei embark am initializat prima pozitie din heap si mi-am creat un nou vector de heap pentru a avea mai mult spatiu, iar apoi voi schimba referinta vechiului vector de heap. Voi decrementa si dimensiunea vectorului de heap. Daca dimensiunea este diferita de 1, atunci voi apela metoda maxHeap(0). In metoda maxHeap voi realiza interschimbarile necesare pentru a crea un maxHeap. In cadrul metodei prin voi verifica daca respectiva diferenta este < 0, iar in az afirmativ ies din functie, altfel daca nu este asa, afisez in fisierul de output prioritatea de pozitia pos, iar apoi apelez recursiv pe stanga si pe dreapta. In metoda delete, voi realiza stergerea unui pasager in functie de numele sau din entitate comparand id-ul din heap cu cel primit ca parametru, recarculez prioritatea entitatii din heap, iar apoi resortez heap-ul. Supraincarc metoda delete in care Realizez stergerea entitatii din heap prin compararea entitatii primite ca parametru cu cea din heap, iar daca sunt egale, atunci voi interschimba radacina cu nodul in care se gaseste id-ul entitatii. In metoda list, apelez functia prezentata anterior de la pozitia 0.

	In clasa Imbarcare mi-am declarat vectorii de familii, grupuri si singur, de tipul Familie, Grup, Singur, vectorii pentru prioritatea lor, de tipul intreg, o instanta a clasei Heap si un obiect care imi va retine asociatii intre obiecte de tipul HashMap. Am realizat constructorul clasei, fiecare vector pornind de pe pozitia 0. Am realizat set-eri si get-eri pentru fiecare camp, just in case. In metoda de adaugare, add, realizez adaugarea pasagerilor intr-o entitate. In cazul in care prima litera este 'f', atunci ma duc in vectorul de familii si verific daca pasagerul care face parte dintr-o anumite familie are familia in vector si ii calculez prioritatea pe care o adaug la prioritatea familiei, iar daca nu, adaugam in vector respectiva familie si calculam prioritatea pentru repsectivul pasasger. Analog pentru grupuri si singuri. In metoda de inserare, realizez atribuirea punctelor corespunzatoare si inserarea in heap, atat pentru familie, cat si pentru grup si singur.

	In interiorul clasei MainReader realizez citirea din fisier prin intermediul clasei Scanner. In metoda open realizez deschiderea fisierului, iar daca acesta va genera vreo eroare pentru ca nu a putut fi deschis se va afisa in consola faptul ca fisierul nu poate fi deschis. In metoda citeste_pasager, preiau din fisier fiecare coloana din linia ce descrie pasagerul prin intermediul clasei String si realizez conversiile necesare. In metoda read realizez adaugarea pasagerilor, inserarea, embark-ul, listarea si delete-ul unui pasager sau a unei entitati din heap. Metoda close este folosita pentru a inchide fisierul deschis adineauri.

	In cadrul clasei Main voi realiza deschiderea, citirea si inchiderea fisierului de input si scrierea in fisierul de output.

	
